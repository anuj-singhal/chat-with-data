"""
LLM-driven Task Decomposer Agent
All decomposition logic is handled by the LLM, not rules
"""

import json
import logging
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field
from datetime import datetime
from .llm_interface import AgenticLLMInterface

logger = logging.getLogger(__name__)


@dataclass
class AgenticTask:
    """Represents a task generated by LLM"""
    task_id: str
    description: str
    sql_query: str
    dependencies: List[str] = field(default_factory=list)
    execution_type: str = "sequential"  # parallel or sequential
    result: Optional[Any] = None
    status: str = "pending"


@dataclass 
class AgenticPlan:
    """Execution plan generated by LLM"""
    plan_id: str
    original_query: str
    tasks: List[AgenticTask]
    execution_order: List[List[str]]  # Batches of task IDs
    synthesis_instructions: str
    created_at: datetime = field(default_factory=datetime.now)


class LLMTaskDecomposer:
    """Uses LLM to decompose complex queries into tasks"""
    
    def __init__(self, llm_interface: AgenticLLMInterface, rag_system=None):
        self.llm = llm_interface
        self.rag_system = rag_system
        
    async def decompose_query(self, query: str) -> AgenticPlan:
        """
        Use LLM to decompose a complex query into executable tasks
        """
        
        # Get schema context from RAG if available
        context = ""
        if self.rag_system:
            search_results = self.rag_system.search_relevant_tables(query)
            rag_context = self.rag_system.build_context(search_results['tables'], query)
            
            # Format schema for LLM
            context = self._format_schema_context(rag_context)
        
        try:
            # Get LLM to decompose the query
            plan_data = await self.llm.decompose_query(query, context)
            
            if not plan_data or 'tasks' not in plan_data:
                logger.warning("LLM decomposition returned empty or invalid data")
                return self._create_fallback_plan(query)
            
            # Create plan from LLM response
            plan = self._create_plan_from_llm(query, plan_data)
            
            logger.info(f"Created plan with {len(plan.tasks)} tasks")
            return plan
            
        except Exception as e:
            logger.error(f"Failed to decompose query: {e}")
            return self._create_fallback_plan(query)
    
    def _format_schema_context(self, rag_context: Dict[str, Any]) -> str:
        """Format RAG context for LLM"""
        schema_text = []
        
        for table_name, table_info in rag_context.get('tables', {}).items():
            schema_text.append(f"\nTable: {table_name}")
            schema_text.append(f"Description: {table_info['description']}")
            schema_text.append("Columns:")
            
            for col in table_info['columns']:
                col_text = f"  - {col['name']} ({col['type']})"
                if col.get('is_pk'):
                    col_text += " PRIMARY KEY"
                col_text += f": {col['description']}"
                
                if col.get('samples'):
                    col_text += f" (Examples: {col['samples'][:2]})"
                
                schema_text.append(col_text)
        
        # Add relationships
        if rag_context.get('relationships'):
            schema_text.append("\nRelationships:")
            for rel in rag_context['relationships']:
                schema_text.append(f"  - {rel['from']} -> {rel['to']}: {rel['description']}")
        
        return "\n".join(schema_text)

    
    def _create_plan_from_llm(self, query: str, plan_data: Dict[str, Any]) -> AgenticPlan:
        """Create AgenticPlan from LLM response"""
        
        tasks = []
        for task_data in plan_data.get('tasks', []):
            task = AgenticTask(
                task_id=task_data['task_id'],
                description=task_data['description'],
                sql_query=task_data['sql_query'],
                dependencies=task_data.get('dependencies', []),
                execution_type=task_data.get('execution_type', 'sequential')
            )
            tasks.append(task)
        
        plan = AgenticPlan(
            plan_id=f"plan_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            original_query=query,
            tasks=tasks,
            execution_order=plan_data.get('execution_order', []),
            synthesis_instructions=plan_data.get('synthesis_instructions', '')
        )
        
        return plan
    
    def _create_fallback_plan(self, query: str) -> AgenticPlan:
        """Create a simple single-task plan as fallback"""
        
        task = AgenticTask(
            task_id="T1",
            description="Execute full query",
            sql_query=f"-- {query}\nSELECT * FROM banks LIMIT 10",
            dependencies=[],
            execution_type="sequential"
        )
        
        plan = AgenticPlan(
            plan_id=f"plan_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            original_query=query,
            tasks=[task],
            execution_order=[["T1"]],
            synthesis_instructions="Return the query results as is"
        )
        
        return plan